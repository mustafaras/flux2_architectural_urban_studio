"""
Phase 6 Enhanced Watermarking Interface.

Provides a config-driven wrapper around the existing watermark system
with robustness checks for common image transformations.
"""

from __future__ import annotations

from dataclasses import dataclass
from io import BytesIO
from pathlib import Path
from typing import Any, Dict, Optional

import torch
import numpy as np
from PIL import Image

from flux2.watermark import (
    WatermarkEmbedder,
    WatermarkMode,
    WatermarkPosition,
    create_watermark_embedder,
)


@dataclass
class EnhancedWatermarkConfig:
    """Runtime watermark configuration loaded from safety YAML."""

    enabled: bool = True
    mode: WatermarkMode = WatermarkMode.INVISIBLE
    opacity: float = 0.3
    position: WatermarkPosition = WatermarkPosition.BOTTOM_RIGHT
    text: str = "Generated by FLUX.2"
    c2pa_enabled: bool = False


class EnhancedWatermarkingSystem:
    """Enhanced watermarking orchestrator with config reloading and robustness evaluation."""

    def __init__(self, config_path: Optional[Path] = None):
        self.config_path = config_path or Path("src/flux2/safety_config.yaml")
        self.config = EnhancedWatermarkConfig()
        self.reload_config()

    def reload_config(self) -> EnhancedWatermarkConfig:
        """Reload watermark settings from config file without restart."""
        config_data = self._load_yaml()
        wm_data = config_data.get("watermarking", {}) if isinstance(config_data, dict) else {}

        mode_value = wm_data.get("mode", WatermarkMode.INVISIBLE.value)
        position_value = wm_data.get("position", WatermarkPosition.BOTTOM_RIGHT.value)

        self.config = EnhancedWatermarkConfig(
            enabled=bool(wm_data.get("enabled", True)),
            mode=WatermarkMode(mode_value) if mode_value in [m.value for m in WatermarkMode] else WatermarkMode.INVISIBLE,
            opacity=float(wm_data.get("opacity", 0.3)),
            position=WatermarkPosition(position_value)
            if position_value in [p.value for p in WatermarkPosition]
            else WatermarkPosition.BOTTOM_RIGHT,
            text=str(wm_data.get("text", "Generated by FLUX.2")),
            c2pa_enabled=bool(wm_data.get("c2pa_enabled", False)),
        )
        return self.config

    def create_embedder(self) -> WatermarkEmbedder:
        """Build watermark embedder from active config."""
        mode = self.config.mode if self.config.enabled else WatermarkMode.NONE
        return create_watermark_embedder(
            mode=mode,
            visible_text=self.config.text,
            position=self.config.position,
            opacity=self.config.opacity,
        )

    def apply(self, image: torch.Tensor, metadata: Optional[Dict[str, Any]] = None) -> torch.Tensor:
        """Apply configured watermark to an image tensor."""
        embedder = self.create_embedder()
        return embedder(image, metadata=metadata)

    def evaluate_robustness(
        self,
        image: torch.Tensor,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        """Run lightweight robustness checks against JPEG90 and resize operations."""
        base = self.apply(image, metadata=metadata)
        jpeg_variant = self._simulate_jpeg_quality(base, quality=90)
        resize_variant = self._simulate_resize(base, scale=0.75)

        jpeg_similarity = self._cosine_similarity(base, jpeg_variant)
        resize_similarity = self._cosine_similarity(base, resize_variant)

        return {
            "jpeg90_similarity": float(jpeg_similarity),
            "resize_similarity": float(resize_similarity),
            "jpeg90_survives": bool(jpeg_similarity > 0.90),
            "resize_survives": bool(resize_similarity > 0.85),
        }

    def _load_yaml(self) -> Dict[str, Any]:
        if not self.config_path.exists():
            return {}
        try:
            import yaml

            with open(self.config_path, "r", encoding="utf-8") as f:
                loaded = yaml.safe_load(f) or {}
                return loaded if isinstance(loaded, dict) else {}
        except Exception:
            return {}

    def _simulate_jpeg_quality(self, image: torch.Tensor, quality: int) -> torch.Tensor:
        pil_image = self._tensor_to_pil(image)
        buffer = BytesIO()
        pil_image.save(buffer, format="JPEG", quality=quality)
        buffer.seek(0)
        degraded = Image.open(buffer).convert("RGB")
        return self._pil_to_tensor(degraded, image.device, image.dtype)

    def _simulate_resize(self, image: torch.Tensor, scale: float) -> torch.Tensor:
        pil_image = self._tensor_to_pil(image)
        width, height = pil_image.size
        resized_down = pil_image.resize((max(1, int(width * scale)), max(1, int(height * scale))), Image.BILINEAR)
        resized_up = resized_down.resize((width, height), Image.BILINEAR)
        return self._pil_to_tensor(resized_up, image.device, image.dtype)

    def _cosine_similarity(self, left: torch.Tensor, right: torch.Tensor) -> float:
        left_flat = left.detach().float().view(-1)
        right_flat = right.detach().float().view(-1)
        denom = (torch.norm(left_flat) * torch.norm(right_flat)).item()
        if denom == 0:
            return 0.0
        return float(torch.dot(left_flat, right_flat).item() / denom)

    def _tensor_to_pil(self, tensor: torch.Tensor) -> Image.Image:
        image = tensor
        if len(image.shape) == 5:
            image = image[0, 0]
        elif len(image.shape) == 4:
            image = image[0]

        image = (image + 1) * 127.5
        image = torch.clamp(image, 0, 255).detach().cpu().numpy().astype("uint8")
        image = image.transpose(1, 2, 0)
        return Image.fromarray(image)

    def _pil_to_tensor(self, image: Image.Image, device: torch.device, dtype: torch.dtype) -> torch.Tensor:
        array = torch.from_numpy(np.array(image).transpose(2, 0, 1)).to(device=device, dtype=dtype)
        tensor = array / 127.5 - 1
        return tensor.unsqueeze(0).unsqueeze(0)
